# redis

### Redis 特点

> - 性能极高的key-value型数据库
> - 大量的数据结构与并允许自己添加外部扩展的数据结构
> - 支持数据的持久化，可以将内存中的数据保存在磁盘中
> - 支持数据的备份，即master-slave模式的数据备份
> - 单线程化阻塞io,每一个操作都是原子化 – Redis的所有操作都是原子性的.单线程避免了不必要的上下文切换和竞争条件

但是要注意上面的优势也会带来问题
> - 持久化,需要RDB AOF,也会带来性能上的损失,同时这些持久化操作,也需要考虑数据不一致的问题
> - 队列原子化也意味着某些长时间命令,会大大拖慢redis的访问.比如key命令.可以使用slowlog来查看

### Redis 有哪些数据类型
redis常用的数据结构  string、list、hash、set、sortset, bitmap(位图), HyperLogLog, Pub/Sub(分布订阅机制)

位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是byte数组。可以使用普通的get/set直接获取和设置整个位图的内容，
HyperLogLog提供不精确的去重计数方案，虽然不精确但是也不是非常不精确，标准误差是0.81%

同时外部扩展下还支持诸如bloomfliter,rejson,Redis Graph 这些新的数据结构

### 一致性哈希

关于一致性哈希请参看下面的[文章](https://zhuanlan.zhihu.com/p/34985026)

Redis集群没有使用一致性hash,而是引入了哈希槽的概念.

redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node<->slot<->value.
当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，cluster 决定将一个key放到哪个桶slot中.

16348=（2的14次方）

https://github.com/antirez/redis/issues/2576

这个数字的解答

- 正常的心跳包携带节点的完整配置，可以用幂等方式替换旧节点以更新旧配置。 这意味着它们包含原始形式的节点的插槽配置，它使用带有16k插槽的2k空间，但使用65k插槽时将使用高达8k的空间。
- 同时，由于其他设计权衡，Redis Cluster不太可能扩展到超过1000个主节点。
因此，16k处于正确的范围内，以确保每个主站有足够的插槽，最多1000个主站，但足够小的数字可以轻松地将插槽配置传播为原始位图。 请注意，在小型集群中，位图难以压缩，因为当N很小时，位图将设置插槽/ N位，这是设置的大部分位。

### 如何实现分布式锁
单机版本下  先拿setnx来争抢锁，设置过期时间,

SET resource_name my_random_value NX PX 30000
上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。

	- my_random_value是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。
	- NX表示只有当resource_name对应的key值不存在的时候才能SET成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得
  - PX 30000表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。


最后，当客户端完成了对共享资源的操作之后，执行下面的Redis Lua脚本来释放锁：
```
if redis.call("get",KEYS[1]) == ARGV[1] then
return redis.call("del",KEYS[1])
else
return 0
end
```

对于多机器备份下

作者antirez提出了新的分布式锁的算法Redlock，它基于N个完全独立的Redis节点的一组算法.当然这个算法,在发布时候还是引发很大的争议.一致性问题的专家一般建议使用专门的分布式锁而不是这个算法来处理分布式问题.   

### Redis 如何实现持久化

RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储. 会按照配置的指定时间将内存中的数据快照到磁盘中
AOF持久化方式. 以日志的形式记录每个写操作（读操作不记录），只需追加文件但不可以改写文件. 主要有两种方式触发：有写操作就写、每秒定时写（也会丢数据）

### 事务支持
事务提供了一种将多个命令打包，然后一次性、有序地执行的机制.Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）

redis提供事务,但是不提供回滚.事务中有某条/某些命令执行失败了,事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令.

redis提供 check-and-set机制来实现乐观锁

````
$redis->watch('x'); // or for a list of keys: $redis->watch(['x','another key']);
/* long code here during the execution of which other clients could well modify `x` */
$ret = $redis->multi() ->incr('x') ->exec();
/*$ret = FALSE if x has been modified between the call to WATCH and the call to EXEC.*/
````

CAS的实现主要通过watch命令完成，也就是说在watch一个key后，其他终端修改此key的值时，都将触发当前事务的失败

### 你之前为了解决什么问题使用的什么，为什么选它

附带商品有各种计数（喜欢数，评论数，鉴定数，浏览数,etc）
Redis的命令都是原子性的，你可以轻松地利用INCR，DECR等命令来计数记录用户刚刚喜欢的商品最新列表or排行榜 等业务场景这个在我的博客里面有提到.
这几个使用redis缓存的原因在于,数据变动大,如果放到mysql中,无法保存数据的一致性.同时redis的实现更加简单.

抢购模型.比如之前实现的微信防止盗刷,就是一个典型的抢购模型,使用一个乐观锁实现.在我的博客中也有过分析.

redis实现抢购
大概是两个思路一个是使用cas乐观锁来保存当前的商品库存,一旦库存被修改就抢购失败,

第二个思路是使用队列,吧库存当做是队列的一部分,队列被分发完毕,则库存消失

核心是两点第一,是使用redis的原子化,因为redis是单线程的,操作都是给予队列的.使用list保存库存可以只有队列为空,而不会出现超卖的情况,实质上是把对于库存的操作限制在队列内.

使用它的原因,使用mysql的乐观锁的性能不够,而redis的抢购模型已经足够便利.有现成的demo可用.

### 内存淘汰机制
Redis内存淘汰指的是用户存储的一些键被可以被Redis主动地从实例中删除，从而产生读miss的情况

本质上是为了避免出现虚拟内存后造成的频繁的swap,造成的抖动.用一定的缓存miss来换取内存的使用效率.

- volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
-noeviction：禁止驱逐数据，当内存使用达到阈值的时候，所有引起申请内存的命令会报错
3.2.3版本里默认是volatile-lru

### redis 的 set 是怎么实现的
主要是对 intset 和 dict 两个数据结构的操作函数的包装， 以及一些在两种编码之间进行转换的函数.
在数量超过一定限制的情况下变为字典.-

### 有序集合底层实现？跳跃表和平衡二叉树效率对比
使用跳跃表和字典来实现.通过字典来O(1) 来实现访问,通过跳跃表提升范围访问的效率.要注意在数量较少时候,会有序集合会采用ziplist,只有数目超过设置的参数后才一会采用跳跃表.

查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当.跳跃表的内存占用和时间复杂度缓存局部性至少与其他类型的平衡树一样好.更重要的是他容易实现和调优.这也是Redis的作者 @antirez 的观点
